---
output: github_document
editor_options: 
  markdown: 
    wrap: 72
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# cheapr <a href="https://github.com/NicChr/cheapr"><img src="man/figures/cheapr_logo.png" align="right" height="238"/></a>

<!-- badges: start -->

[![R-CMD-check](https://github.com/NicChr/cheapr/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/NicChr/cheapr/actions/workflows/R-CMD-check.yaml)
[![CRAN
status](https://www.r-pkg.org/badges/version/cheapr)](https://CRAN.R-project.org/package=cheapr)
[![Codecov test
coverage](https://codecov.io/gh/NicChr/cheapr/graph/badge.svg)](https://app.codecov.io/gh/NicChr/cheapr)

<!-- badges: end -->

In cheapr, 'cheap' means fast and memory-efficient, and that's exactly
the philosophy that cheapr aims to follow.

## Installation

You can install cheapr like so:

``` r
install.packages("cheapr")
```

or you can install the development version of cheapr:

``` r
remotes::install_github("NicChr/cheapr")
```

cheapr is primarily an extension to R for developers that want to write
clean, fast and safe code without sacrificing any one of these core
design principles.

## cheapr C/C++ API

cheapr includes a feature-rich C API that can be used interchangeably
with the R C API. Despite the API requiring C++17 and making heavy use
of C++ templates, C++ objects cannot be safely used. More specifically,
C++ objects with destructors cannot be safely used because when R
encounters an error, it terminates in a way that doesn't run these
destructors, leading to memory leaks. This applies to any C++ object
with a destructor like `std::string` and `std::vector`.

To safely call R C API functions or cheapr C++ functions (from c_api.h)
one must wrap these R C API functions with `cpp11::safe[]` or cheapr's
`r_safe` macro. For more info see cpp11's FAQ section 15 [Should I call
cpp11::unwind_protect()
manually?](https://cpp11.r-lib.org/articles/FAQ.html)

The reason we have opted for a mostly C API with C++ templates is for
maximal speed, efficiency and interoperability with the R C API.

We aim to create a fully C++ compatible API in an upcoming release.

## C/C++ API features

R internally labels all R allocated objects as `SEXP` which is an
abbreviation for "S expression". This naturally creates ambiguity
regarding the type of R object we are dealing with, which is canonically
disambiguated via the use of R's `TYPEOF()`. While this provides
flexibility, it also makes programming more cumbersome and complicated.
All R objects are `SEXP` which includes not only vectors (integer,
character, etc) but also non-vector objects such as symbols, functions,
etc.

### cheapr C/C++ types

The current available types are:

-   r_bool_t - Contains either `r_true`, `r_false`, or `r_na`
    (internally 1, 0, or NA_INTEGER)

-   r_string_t - Alias type for R strings `CHARSXP`

-   r_symbol_t - Alias type for R symbols `SYMSXP`

-   r_complex_t - Alternative to Rcomplex type

-   r_byte_t - Alias type for Rbyte

It's important to note that these types must be preferred over the R C
API types to allow cheapr's templates to work correctly and efficiently.

In an effort to distinguish vectors and non-vectors (including C/C++
types) we have created aliases for `CHARSXP` and `SYMSXP`, which are
`r_string_t` and `r_symbol_t` respectively. To interact with R strings
(`CHARSXP`) objects with the cheapr API, one must label all of them
`r_string_t` \
The same goes for symbols (`SYMSXP`).

\
All template functions depend on the `SEXP` type being reserved for any
R object that isn't a `CHARSXP` or `SYMSXP`. For example `new_vector<T>`
is a template that creates a new R vector based on the type of objects
`T` it holds.\
`new_vector<int>` will create an R integer vector and `new_vector<SEXP>`
will always create a list vector. In the pure R C API `SEXP` would be
ambiguous in this scenario, in cheapr it is not because there are
dedicated types for R strings and symbols. Since the only vector that
can hold all other `SEXP` is a list, then the result of
`new_vector<SEXP>` must also be a list. If we had to check the type of
`SEXP` (via `TYPEOF()`) in each `<SEXP>` template specialisation, this
would slow things down considerably.\
\
For all other `SEXP` objects we have opted to continue using `SEXP` for
flexibility.

`CHARSXP` is R's string type that identifies the elements of a character
vector. Remember it is also an `SEXP` and its internal type `CHARSXP`
can only be revealed via `TYPEOF()`. When working with these R strings
in cheapr we recommend assigning them as `r_string_t` for clarity and
performance.

The advantages of using `r_string_t` over `SEXP` for CHARSXP objects
are:

-   It clearly identifies that it is an R string which we are calling
    `r_string_t`, similar in naming convention to C++ types like
    `int32_t`

-   Template functions like `is_r_na()` have been written with a
    specialisation for `r_string_t` and thus having this differentiated
    type instead of `SEXP` is more efficient.

`SYMSXP` is used for R symbols and is heavily used for attribute
manipulation, expression evaluation and more. cheapr internally labels
these symbols as `r_symbol_t` for similar reasons to `r_string_t`

`r_cast<>`

For those familiar with C++ and `static_cast<>` the intent of this
function is hopefully clear. `r_cast<>` can convert between C/C++ types
while being very careful to handle `NA` values properly.

For example `r_cast<int>(NA_REAL)` returns `NA_INTEGER` and inversely
`r_cast<double>(NA_INTEGER)` returns `NA_REAL`. This is not the case for
`static_cast<>` which will convert `NA_INTEGER` to its literal internal
representation, the smallest (usually 32-bit) integer.

As for referencing `NA` values in cheapr, these are all defined the `na`
namespace.

`NA` values and their R equivalents

-   `na::logical` (r_bool_t) - `NA`

-   `na::integer` (int) - `NA_INTEGER_`

-   `na::real` (double) - `NA_REAL_`

-   `na::complex` (Rcomplex) - `NA_COMPLEX_`

-   `na::string` (r_string_t) - `NA_CHARACTER_`

## Creating new vectors

Creating new vectors can be done via `new_vector<>`\
For example, to create a new integer vector of length 10, specify
`new_vector<int>(10)` and to\
create a new character vector of length 20, specify
`new_vector<r_string_t>(20)`. Supply the 2nd argument to give a default
value to fill all the elements with,\
e.g. `new_vector<int>(100, na::integer)`

All vectors are created using multiple threads (except for character and
list vectors).\
To set the number of threads, simply use `cheapr::set_threads()` in
either R or C/C++

## Scalar vectors

To efficiently create length-one vectors directly from C/C++ types, use
`as_vec<>`\
For example, to create a length-one character vector from a string, we
can run `as_vec("hello")` or\
`as_vec(r_cast<r_string_t>("hello"))`

Alternatively use `as_r_obj` to convert any object to an R (`SEXP`)
object. The caveat is that `CHARSXP` / `r_string_t` objects are always
converted to `STRSXP` (character vectors). Some of the rationale for
this is that `CHARSXP` objects are (typically) never returned in R and
only used in internal C code whereas symbols (`SYMSXP`) can be returned
in R and are used frequently.

## Combining values with `combine()`

There is quite a lot of work under-the-hood to make this work well. It
behaves like `c()` and indeed is part of the underlying code for the R
function `cheapr::c_()`\
In a nutshell it can combine both C/C++ types and R vectors into one
single vector.\
To do this it will cast all objects to a single common type. For more
detail see `?cast`\
For example,
`combine(1, 2.5, "str1", r_cast<r_string_t>("str2"), as_vec("str3"))`
will\
return the character vector `c("1", "2.5", "str1", "str2", "str3")`
because the common type that\
these objects can be cast to is a character vector.

## Creating lists

Creating lists is also easy with `make_list()`. For example,
`make_list(1, 2, 3)` and
`make_list(arg("x") = 1, arg("y") = 2, arg("z") = 3)` are equivalent to
the R version `list(1, 2, 3)` and `list(x = 1, y = 2, z = 3)`

## Math in C/C++

Many simple math functions are available in the `cheapr::math`
namespace, e.g. `math::r_abs()`\
`math::r_round()` (which uses round-to-even), `math::r_gcd()` and more.
These also handle `NA`, `NaN`, and `Inf` values carefully.

## cheapr R API

Some common R operations that cheapr can do much faster and more
efficiently include:

-   Handling `NA` values very efficiently

-   Counting, finding, removing and replacing scalar values

-   Type-stable one-way casting and common-casting

-   Combining vectors

-   Creating and manipulating factors

-   Pasting strings

-   Creating multiple sequences in a vectorised way

-   Sub-setting vectors and data frames efficiently

-   Safe, flexible and fast greatest common divisor and lowest common
    multiple

-   Lags/leads

-   `integer64` support

-   In-memory Math (no copies, vectors updated by reference)

-   Summary statistics

-   Counts

-   Modifying lists

-   Recycling

-   Binning of continuous data

### Scalars and `NA`

Let's first load the required packages

```{r}
library(cheapr) 
library(bench)
```

Because R mostly uses vectors and vectorised operations, this means that
there are few scalar-optimised operations.

cheapr provides tools to efficiently count, find, replace and remove
scalars.

```{r}
# Setup data with NA values
set.seed(42)
x <- sample(1:5, 30, TRUE)
x <- na_insert(x, n = 7)

counts(x) # Fast counts
```

`NA` functions

```{r}
na_count(x)
na_rm(x)
na_find(x)
na_replace(x, -99)
```

Scalar functions

```{r}
val_count(x, 3)
val_rm(x, 3)
val_find(x, 3)
val_replace(x, 3, 99)
```

Scalar based case-match

```{r}
val_match(
  x, 
  1 ~ "one", 
  2 ~ "two",
  3 ~ "three", 
  .default = ">3"
)
```

## Efficient NA counts by row/col

```{r}
m <- matrix(na_insert(rnorm(10^6), prop = 1/4), ncol = 10^3)
# Number of NA values by row
mark(row_na_counts(m), 
     rowSums(is.na(m)))
# Number of NA values by col
mark(col_na_counts(m), 
     colSums(is.na(m)))
```

`is_na` is a multi-threaded alternative to `is.na`

```{r}
x <- rnorm(10^6) |> 
  na_insert(10^5)
set_threads(4)
mark(is.na(x), is_na(x))
set_threads(1)
mark(is.na(x), is_na(x))
set_threads(2)

### posixlt method is much faster
hours <- as.POSIXlt(seq.int(0, length.out = 10^6, by = 3600),
                    tz = "UTC") |> 
  na_insert(10^5)

mark(is.na(hours), is_na(hours))
```

It differs in 2 regards:

-   List vectors are never regarded as `NA` even if they contain `NA`
    values.
-   For data frames, `is_na` returns a logical vector where `TRUE`
    defines an empty row of only `NA` values.

```{r}
# List example
is.na(list(NA, NULL, 10))
is_na(list(NA, NULL, 10))

# Data frame example
df <- new_df(x = c(1, NA, 3),
             y = c(NA, NA, NA))
df
is_na(df)
is_na(df)
# The below identity should hold
identical(is_na(df), row_na_counts(df) == ncol(df))
```

`is_na` and all the `NA` handling functions fall back on calling
`is.na()` if no suitable method is found. This means that custom objects
like vctrs rcrds and more are supported.

## Cheap data frame summaries with `overview`

Inspired by the excellent skimr package, `overview()` is a cheaper
alternative designed for larger data.

```{r}
df <- new_df(
  x = sample.int(100, 10^6, TRUE),
  y = as_factor(sample(LETTERS, 10^6, TRUE)),
  z = rnorm(10^6)
)
overview(df)
mark(overview(df, hist = FALSE))
```

## Cheaper and consistent subsetting with `sset`

```{r}
sset(iris, 1:5)
sset(iris, 1:5, j = "Species")

# sset always returns a data frame when input is a data frame

sset(iris, 1, 1) # data frame
iris[1, 1] # not a data frame

x <- sample.int(10^6, 10^4, TRUE)
y <- sample.int(10^6, 10^4, TRUE)
mark(sset(x, x %in_% y), sset(x, x %in% y), x[x %in% y])
```

`sset` uses an internal range-based subset when `i` is an ALTREP integer
sequence of the form m:n.

```{r}
mark(sset(df, 0:10^5), df[0:10^5, , drop = FALSE])
```

It also accepts negative indexes

```{r}
mark(sset(df, -10^4:0), 
     df[-10^4:0, , drop = FALSE],
     check = FALSE) # The only difference is the row names
```

The biggest difference between `sset` and `[` is the way logical vectors
are handled. The two main differences when `i` is a logical vector are:

-   `NA` values are ignored, only the locations of `TRUE` values are
    used.
-   `i` must be the same length as `x` and is not recycled.

```{r,error=TRUE}
# Examples with NAs
x <- c(1, 5, NA, NA, -5)
x[x > 0]
sset(x, x > 0)

# Example with length(i) < length(x)
sset(x, TRUE)

# This is equivalent 
x[TRUE]
# to..
sset(x)
```

## Combining vectors fast and consistently

```{r}
x <- as_factor(letters)
```

Base R combining

```{r}
c(x, letters)
c(letters, x)
```

With cheapr the order of arguments doesn't affect the outcome type

```{r}
c_(x, letters);c_(letters, x)
```

Same goes for other types likes Dates and Date-Times

```{r}
today <- Sys.Date()
now <- Sys.time()

c(today, now);c(now, today) # base
c_(today, now);c_(now, today) # cheapr
```

`c_()` combines date frames by row

```{r}
sset(iris, 1) |> 
  c_(sset(iris, 2))
```

Alternatively combine by column

```{r}
sset(iris, 1:3, j = 1) |> 
  col_c(sset(iris, 1:3, j = 2))
```

## Casting and Coercion

We can cast from one type to another with `cast()`

```{r}
ints <- 1:10
dbls <- seq_(from = 1, to = 10, by = 0.5)
chrs <- letters
fctr <- as_factor(letters)
df <- new_df(a = ints, b = dbls, c = chrs, d = fctr)

cast(ints, dbls) |> print() |> class()
cast(dbls, ints) |> print() |> class()
cast(dbls, chrs) |> print() |> class()
cast(chrs, fctr) |> print() |> class()
cast(fctr, chrs) |> print() |> class()
cast(dbls, fctr) |> print() |> class()
cast(fctr, dbls) |> print() |> class()
cast(ints, df) |> print() |> class()
```

We can also cast multiple objects to a common type

```{r}
cast_common(ints, dbls)
cast_common(ints, dbls, chrs)
cast_common(ints, dbls, chrs, fctr)
cast_common(ints, dbls, chrs, fctr, df)
```

When common-casting factors, their levels are combined

```{r}
cast_common(fctr, as_factor(LETTERS))
cast_common(as_factor(LETTERS), fctr)
```

## Vector and data frame lags with `lag_()`

```{r}
set.seed(37)
lag_(1:10, 3) # Lag(3)
lag_(1:10, -3) # Lead(3)

# Using an example from data.table
library(data.table)
data.table::setDTthreads(2);
dt <- data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5])

# Similar to data.table::shift()

lag_(dt, 1) # Lag 
lag_(dt, -1) # Lead
```

With `lag_` we can update variables by reference, including entire data
frames

```{r}
# At the moment, shift() cannot do this
lag_(dt, set = TRUE)

dt # Was updated by reference
```

`lag2_` is a more generalised variant that supports vectors of lags,
custom ordering and run lengths.

```{r}
lag2_(dt, order = 5:1) # Reverse order lag (same as lead)
lag2_(dt, -1) # Same as above
lag2_(dt, c(1, -1)) # Alternating lead/lag
lag2_(dt, c(-1, 0, 0, 0, 0)) # Lead e.g. only first row
```

## Greatest common divisor and smallest common multiple

```{r}
gcd2(5, 25)
scm2(5, 6)

gcd(seq(5, 25, by = 5))
scm(seq(5, 25, by = 5))

x <- seq(1L, 1000000L, 1L)
mark(gcd(x))
x <- seq(0, 10^6, 0.5)
mark(gcd(x))
```

## Creating many sequences

As an example, to create 3 sequences with different increments,\
the usual approach might be to use lapply to loop through the increment
values together with `seq()`

```{r}
# Base R
increments <- c(1, 0.5, 0.1)
start <- 1
end <- 5
unlist(lapply(increments, \(x) seq(start, end, x)))
```

In cheapr you can use `seq_()` which accepts vector arguments.

```{r}
seq_(start, end, increments)
```

Use `as_list` to return a list of sequences

```{r}
seq_(start, end, increments, as_list = TRUE)
```

If you know the sizes of your sequences beforehand, use `sequence_()`

```{r}
seq_sizes <- c(3, 5, 10)
sequence_(seq_sizes, from = 0, by = 1/3, as_list = TRUE)
```

You can also calculate sequence sizes, starts, ends and increments

```{r}
seq_size(from = 1, to = 10, by = c(0.5, 1))
seq_start(size = c(19, 10), to = 10, by = c(0.5, 1))
seq_end(size = c(19, 10), from = 1, by = c(0.5, 1))
seq_increment(size = c(19, 10), from = 1, to = 10)
```

## Math in-place

cheapr provides a full set of common math functions that can transform
numeric vectors in-place (no copies)

```{r}
(x <- seq(0, 5, by = 0.5))

# x is modified in-place
set_add(x, 10);x
set_subtract(x, 10);x
set_multiply(x, 10);x
set_divide(x, 10);x

set_change_sign(x);x
set_abs(x);x
set_round(x);x
set_log(x);x
```

These in-place functions are not always faster than using normal R math
functions. This becomes apparent when performing multiple operations
which R can process simultaneously.

```{r}
x <- rnorm(10^6)
mark(
  x * 10 * 20 + 1 - 1 , 
  set_subtract(set_add(set_multiply(set_multiply(x, 10), 20), 1), 1)
)
```

### `.args`

cheapr now provides `.args` as a means of providing a list of arguments
instead of `...`. This is designed to replace the use of `do.call()`.

In practice this means that users can either supply objects directly to
the dots `...` or as a list of objects.

```{r}
# The below lines are equivalent
c_(1, 2, 3)
c_(.args = list(1, 2, 3))
```

A very common scenario is having a list of objects that you would like
to combine into a vector. Normally one would call `do.call(c, x)` but it
is much more efficient to use the `.args` argument in `c_()`.

```{r}
x <- rep(list(0), 10^5)

mark(
  do.call(c, x),
  c_(.args = x)
)

# Matches the speed of `unlist()` without removing attributes
unlist(list(Sys.Date()), recursive = FALSE)
c_(.args = list(Sys.Date()))
```

## Recycling

Fast base-R style recycling using `recycle()`

```{r}
recycle(letters, pi)

# Data frame rows are recycled
recycle(vector = 1:10, data = cars)

# Using .args
recycle(.args = list(letters, pi))
```

Sizes are recycled to the common maximum, except when a vector is length
0 (excluding NULL which is ignored), in which case they are all recycled
to length 0.

```{r}
recycle(a = 1:3, b = 1:10, c = iris, d = numeric())
```

## Copying

cheapr provides some helpers in the form of `shallow_copy`, `semi_copy`
and `deep_copy`.

```{r}
mark(shallow_copy(iris))
mark(deep_copy(iris))
mark(semi_copy(iris))
```

### `shallow_copy`

Shallow-copies list elements and attributes. When given an atomic vector
it full copies the vector and so is mostly useful for lists.

### `deep_copy`

Full (deep) copies everything, including attributes.

### `semi_copy`

Like `deep_copy` it deep-copies everything, excluding attributes, which
it shallow copies. In practice this turns out to be more efficient.

`semi_copy()` vs `deep_copy()`

```{r}
df <- new_df(x = integer(10^6))
attr(df, "my_attr") <- integer(10^6)

# Take note of the memory allocation
mark(
  semi_copy(df), # Only deep copies the data
  deep_copy(df) # Deep copies "my_attr" as well
)
```

### Attributes

With cheapr you can add and remove attributes flexibly using
`attrs_add()`.

To remove all attributes, use `attrs_rm()`.

To remove specific attributes, use `attrs_add(attr = NULL)`.

```{r}
(x <- attrs_add(1:10, .length = 10, .type = "integer"))

attrs_add(x, .type = NULL) # Remove specific attribute '.type'
attrs_rm(x) # Clear all attributes

# With .args
y <- 11:20
attrs_add(y, .args = attributes(x))
```

Both functions allow setting attributes in-place. This turns out to be
very useful in avoiding implicit copies that R performs when it detects
that the data has been modified.

This must be used with care to not overwrite an existing object's
attributes. Therefore it is best-practice to only use in-place attribute
manipulation on fresh objects, i.e objects that you can ensure are newly
created.

```{r}
add_length_class <- function(x){
  attr(x, ".length") <- length(x)
  attr(x, ".class") <- class(x)
  x
}
add_length_class_in_place <- function(x){
  attrs_add(
    x, .length = length(x), .class = class(x),
    .set = TRUE
  )
}

# Notice the memory allocations
# we expect only 3.81 MB to be allocated
mark(
  add_length_class(integer(10^6)),
  add_length_class_in_place(integer(10^6)),
  iterations = 1
)
mark(
  add_length_class(integer(10^6)),
  add_length_class_in_place(integer(10^6)),
  iterations = 1
)
  

# R detected that the vector we created had been modified (because it was)
# and created a copy
# When we add the attributes in-place to our fresh object, no copies are
# made
```

## 'Cheaper' Base R alternatives

### which

```{r}
x <- rep(TRUE, 10^6)
mark(cheapr_which = which_(x),
     base_which = which(x))
x <- rep(FALSE, 10^6)
mark(cheapr_which = which_(x),
     base_which = which(x))
x <- c(rep(TRUE, 5e05), rep(FALSE, 1e06))
mark(cheapr_which = which_(x),
     base_which = which(x))
x <- c(rep(FALSE, 5e05), rep(TRUE, 1e06))
mark(cheapr_which = which_(x),
     base_which = which(x))
x <- sample(c(TRUE, FALSE), 10^6, TRUE)
x[sample.int(10^6, 10^4)] <- NA
mark(cheapr_which = which_(x),
     base_which = which(x))
```

### factor

```{r}
x <- sample(seq(-10^3, 10^3, 0.01))
y <- do.call(paste0, expand.grid(letters, letters, letters, letters))
mark(cheapr_factor = factor_(x), 
     base_factor = factor(x))
mark(cheapr_factor = factor_(x, order = FALSE), 
     base_factor = factor(x, levels = unique(x)))
mark(cheapr_factor = factor_(y), 
     base_factor = factor(y))
mark(cheapr_factor = factor_(y, order = FALSE), 
     base_factor = factor(y, levels = unique(y)))
```

### intersect & setdiff

```{r}
x <- sample.int(10^6, 10^5, TRUE)
y <- sample.int(10^6, 10^5, TRUE)
mark(cheapr_intersect = intersect_(x, y, dups = FALSE),
     base_intersect = intersect(x, y))
mark(cheapr_setdiff = setdiff_(x, y, dups = FALSE),
     base_setdiff = setdiff(x, y))
```

### `%in_%` and `%!in_%`

```{r}
mark(cheapr = x %in_% y,
     base = x %in% y)
mark(cheapr = x %!in_% y,
     base = !x %in% y)
```

### `as_discrete`

`as_discrete` is a cheaper alternative to `cut`

```{r}
x <- rnorm(10^6)
b <- seq(0, max(x), 0.2)
mark(cheapr_cut = as_discrete(x, b, left = FALSE), 
     base_cut = cut(x, b))
```

### `if_else_`

A cheap alternative to `ifelse`

```{r}
mark(
  if_else_(x >= 0, 1, -1),
  ifelse(x >= 0, 1, -1),
  data.table::fifelse(x >= 0, 1, -1)
)
```

### `case`

cheapr's version of a case-when statement, with mostly the same
arguments as `dplyr::case_when` but similar efficiency as
`data.table::fcase`

```{r}
mark(case(
    x >= 0 ~ "pos", 
    x < 0 ~ "neg", 
    .default = "Unknown"
),
data.table::fcase(
    x >= 0, "pos", 
    x < 0, "neg", 
    rep_len(TRUE, length(x)), "Unknown"
))
```

`val_match` is an even cheaper special variant of `case` when all LHS
expressions are length-1 vectors, i.e scalars

```{r}
x <- round(rnorm(10^6))

mark(
  val_match(x, 1 ~ Inf, 2 ~ -Inf, .default = NaN),
     case(x == 1 ~ Inf, 
          x == 2 ~ -Inf, 
          .default = NaN),
     data.table::fcase(x == 1, Inf, 
          x == 2, -Inf, 
          rep_len(TRUE, length(x)), NaN)
     )
```

`get_breaks` is a very fast function for generating pretty equal-width
breaks It is similar to `base::pretty` though somewhat less flexible
with simpler arguments.

```{r}
x <- with_local_seed(rnorm(10^5), 112)
# approximately 10 breaks
get_breaks(x, 10)
pretty(x, 10)

mark(
  get_breaks(x, 20),
  pretty(x, 20), 
  check = FALSE
)

# Not pretty but equal width breaks
get_breaks(x, 5, pretty = FALSE)
diff(get_breaks(x, 5, pretty = FALSE)) # Widths
```

It can accept both data and a length-two vector representing a range,
meaning it can easily be used in ggplot2 and base R plots

```{r}
library(ggplot2)
gg <- airquality |> 
    ggplot(aes(x = Ozone, y = Wind)) +
    geom_point() + 
    geom_smooth(se = FALSE)

# Add our breaks
gg +
  scale_x_continuous(breaks = get_breaks)

# More breaks

# get_breaks accepts a range too
gg +
  scale_x_continuous(breaks = \(x) get_breaks(range(x), 20)) 
```
